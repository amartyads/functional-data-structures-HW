(*<*)
theory tmpl05
  imports
    Complex_Main
    "HOL-Library.Tree"
begin
(*>*)


text {* \ExerciseSheet{5}{11.~5.~2017} *}

text \<open>
  \<^item> Import \<open>Complex_Main\<close> and \<open>HOL-Library.Tree\<close>
  \<^item> For this exercise sheet (and Homework 1), you are not allowed to use sledgehammer!
    Proofs using the \<open>smt, metis, meson, or moura\<close> methods are forbidden!
\<close>

text \<open>
  \Exercise{Bounding power-of-two by factorial}
  Prove that, for all natural numbers $n>3$, we have $2^n < n!$.
  We have already prepared the proof skeleton for you.
\<close>
lemma exp_fact_estimate: "n>3 \<Longrightarrow> (2::nat)^n < fact n"
proof (induction n)
  case 0 then show ?case by auto
next
  case (Suc n)
  assume IH: "3 < n \<Longrightarrow> (2::nat) ^ n < fact n"
  assume PREM: "3 < Suc n"
  show "(2::nat) ^ Suc n < fact (Suc n)"
    text \<open>Fill in a proof here. Hint: Start with a case distinction
      whether \<open>n>3\<close> or \<open>n=3\<close>. \<close>
    sorry
qed

text \<open>
  \vspace{1em}
  {\bfseries Warning!}
  Make sure that your numerals have the right type, otherwise
  proofs will not work! To check the type of a numeral, hover the mouse over
  it with pressed CTRL (Mac: CMD) key. Example:
\<close>
lemma "2^n \<le> 2^Suc n"
  apply auto oops -- \<open>Leaves the subgoal \<open>2 ^ n \<le> 2 * 2 ^ n\<close>\<close>
  text \<open>You will find out that the numeral \<open>2\<close> has type @{typ 'a},
    for which you do not have any ordering laws. So you have to
    manually restrict the numeral's type to, e.g., @{typ nat}.\<close>
lemma "(2::nat)^n \<le> 2^Suc n" by simp -- \<open>Note: Type inference will
  infer \<open>nat\<close> for the unannotated numeral, too. Use CTRL+hover to double check!\<close>

text \<open>
  \vspace{1em}
\<close>

text \<open>\Exercise{Sum Squared is Sum of Cubes}
  \<^item> Define a recursive function $sumto~f~n = \sum_{i=0\ldots n} f(i)$.
  \<^item> Show that $\left(\sum_{i=0\ldots n}i\right)^2 = \sum_{i=0\ldots n} i^3$.
\<close>


fun sumto :: "(nat \<Rightarrow> nat) \<Rightarrow> nat \<Rightarrow> nat"
where
"sumto f 0 = 0"

text \<open>You may need the following lemma:\<close>
lemma sum_of_naturals: "2 * sumto (\<lambda>x. x) n = n * Suc n"
  (*by (induction n) auto*) oops

lemma "sumto (\<lambda>x. x) n ^ 2 = sumto (\<lambda>x. x^3) n"
proof (induct n)
  case 0 show ?case by simp
next
  case (Suc n)
  assume IH: "(sumto (\<lambda>x. x) n)\<^sup>2 = sumto (\<lambda>x. x ^ 3) n"
  note [simp] = algebra_simps -- \<open>Extend the simpset only in this block\<close>
  show "(sumto (\<lambda>x. x) (Suc n))\<^sup>2 = sumto (\<lambda>x. x ^ 3) (Suc n)"
  text \<open>Insert a proof here\<close>
    sorry
qed

text \<open>
  \Exercise{Paths in Graphs}
  A graph is described by its adjacency matrix, i.e., \<open>G :: 'a \<Rightarrow> 'a \<Rightarrow> bool\<close>.

  Define a predicate \<open>path G u p v\<close> that is true if \<open>p\<close> is a path from
  \<open>u\<close> to \<open>v\<close>, i.e., \<open>p\<close> is a list of nodes, not including \<open>u\<close>, such that
  the nodes on the path are connected with edges.
  In other words, \<open>path G u (p\<^sub>1\<dots>p\<^sub>n) v\<close>, iff \<open>G u p\<^sub>1\<close>, \<open>G p\<^sub>i p\<^sub>i\<^sub>+\<^sub>1\<close>,
  and \<open>p\<^sub>n = v\<close>. For the empty path (\<open>n=0\<close>), we have \<open>u=v\<close>.
\<close>

fun path :: "('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> 'a \<Rightarrow> 'a list \<Rightarrow> 'a \<Rightarrow> bool"
  where
  "path _ _ _ _ \<longleftrightarrow> False"

text \<open>Test cases\<close>
definition "nat_graph x y \<longleftrightarrow> y=Suc x"
value \<open>path nat_graph 2 [] 2\<close>
value \<open>path nat_graph 2 [3,4,5] 5\<close>
value \<open>\<not> path nat_graph 3 [3,4,5] 6\<close>
value \<open>\<not> path nat_graph 2 [3,4,5] 6\<close>

text \<open>Show the following lemma, that decomposes paths. Register it as simp-lemma.\<close>
lemma path_append[simp]: "path G u (p1@p2) v \<longleftrightarrow> (\<exists>w. path G u p1 w \<and> path G w p2 v)"
  oops

text \<open>
  Show that, for a non-distinct path from \<open>u\<close> to \<open>v\<close>,
  we find a longer non-distinct path from \<open>u\<close> to \<open>v\<close>.
  Note: This can be seen as a simple pumping-lemma,
  allowing to pump the length of the path.

  Hint: Theorem @{thm [source] not_distinct_decomp}.
\<close>
lemma pump_nondistinct_path:
  assumes P: "path G u p v"
  assumes ND: "\<not>distinct p"
  shows "\<exists>p'. length p' > length p \<and> \<not>distinct p' \<and> path G u p' v"
  oops


text \<open>
  \NumHomework{Split Lists}{May 18}
  Recall: Use Isar where appropriate, proofs using
    \<open>metis, smt, meson, or moura\<close> (as generated by sledgehammer) are forbidden!

  Show that every list can be split into a prefix and a suffix,
  such that the length of the prefix is \<open>1/n\<close> of the original lists's length.

\<close>

lemma
  assumes "n\<ge>0" -- \<open>Note: This assumption is actually not needed,
    as @{lemma "n div 0 = 0" by auto}, so don't be puzzled if you do
    not use it at all in your proof.\<close>
  shows "\<exists>ys zs. length ys = length xs div n \<and> xs=ys@zs"
  oops

text \<open>
  \NumHomework{Estimate Recursion Equation}{May 18}

  (Sledgehammer allowed again)

  Show that the function defined by \<open>a 0 = 0\<close> and \<open>a (n+1) = (a n)\<^sup>2 + 1\<close>
  is bounded by the double-exponential function \<open>2^(2^n)\<close>
\<close>

fun a :: "nat \<Rightarrow> int" where
"a 0 = 0" |
"a (Suc n) = a n ^ 2 + 1"

text \<open>
  We have given you a proof skeleton, setting up the induction.
  To complete your proof, you should come up with a chain of inequations.
  You may try to solve the intermediate steps with sledgehammer.

  Hint: It is a bit tricky to get the approximation right.
    We strongly recommend to sketch the inequations on paper first.

  Hint: Have a look at the lemma @{thm [source] power_mono}, in particular its
  instance for squares:
\<close>

thm power_mono[where n=2]

lemma "a n \<le> 2 ^ (2 ^ n) - 1"
proof(induction n)
  case 0 thus ?case by simp
next
  case (Suc n)
  assume IH: "a n \<le> 2 ^ 2 ^ n - 1"
    -- \<open>Refer to the induction hypothesis by name \<open>IH\<close> or \<open>Suc.IH\<close>\<close>
  show "a (Suc n) \<le> 2 ^ 2 ^ Suc n - 1"
  proof -
    text \<open>Insert your proof here\<close>
    show ?thesis sorry
  qed
qed


(*<*)
end
(*>*)
